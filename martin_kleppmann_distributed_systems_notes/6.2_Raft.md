* The principles of Raft algorithm help us with thinking about the states in a distributed system.

* *Suspects Leader Failure*: This happens if we do not receive any heartbeat from the leader.

* 4 terms: *currentTerm, votedFor, log, commitLength* need to be maintained in disk.
* The timeout before which a follower suspects that a leader has failed is randomized. We want to avoid all nodes trying to become candidate at the same time.

* In case of suspection of leader election or an election timeout, do the following:
    * Increase the current term.
    * Change the role to candidate.

* Terms are crucial: they help in telling to some already elected leader that it is no longer a leader and should participate in the new election as a candidate.

* A log entry is a combination of a message and a term. 
    * The message should be delivered via total order broadcast.
    * The term is the term number of the the leader. Only the leader can add entry to the log.

**Raft (1/9): Initialisation**

on initialisation do
    currentTerm := 0; votedFor := null; log := {}; commitLength := 0
end on

on recovery from crash do
    currentRole := follower; currentLeader := null; votesReceived := {}; sentLength := 0; ackedLength := 0
end on

on node nodeId suspects leader has failed, or an election timeout do
    currentTerm := currentTerm + 1;
    currentRole := candidate;
    // votes for itself
    votedFor := nodeId; votesReceived := {nodeId};
    
    // find the last term from the log
    lastTerm := 0; if log.length > 0 then lastTerm := log[log.length - 1].term; end if;
    
    // constructs a message and sends it to all nodes, asking for vote
    msg := (VoteReqest, nodeId, currentTerm, log.length, lastTerm)
    for each node in nodes: send msg to node
    start election timer
end on

7:50